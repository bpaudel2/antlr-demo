First create pom.xml including all plugins and dependencies.

Create grammar file for your game in antlr4 package.

Then, run following command to generate classes for your grammar.

>> mvn generate-sources //This will create classes in target/generated-sources/antlr4

Recursive Descent Parsers:

// assign : ID '=' expr ';' ;
void assign() { // method generated from rule assign
match(ID); // compare ID to current input symbol then consume
match('=');
expr(); // match an expression by calling expr()
match(';');
}

/** Match any kind of statement starting at the current input position */
stat: assign // First alternative ('|' is alternative separator)
| ifstat // Second alternative
| whilestat
...
;
A parsing rule for stat looks like a switch.
void stat() {
switch ( «current input token» ) {
CASE ID : assign(); break;
CASE IF : ifstat(); break; // IF is token type for keyword 'if'
CASE WHILE : whilestat(); break;
...
default : «raise no viable alternative exception»
}
}

If the parser detects an ambiguous phrase, it has to pick one of the
viable alternatives. ANTLR resolves the ambiguity by choosing the first
alternative involved in the decision.

ANTLR resolves lexical ambiguities by
matching the input string to the rule specified first in the grammar.

Note that lexers try to match the longest string possible for each token.

We learned that lexers process characters and pass tokens to the
parser, which in turn checks syntax and creates a parse tree. The
corresponding ANTLR classes CharStream, Lexer, Token, Parser and ParseTree.
The piple connecting the lexer and parser is called a TokenStream.

Parse-Tree Listeners and Visitors:

    ANTLR provides support for two tree-walking mechanisms in its
runtime library. By default, ANTLR generates a parse-tree listener interface
that responds to events triggered by the built in tree walker. The
listeners themselves are exactly like SAX document handler objects
for XML parsers.

To walk a tree and trigger calls into listener. ANTLR runtime provides
class ParseTreeWalker. To make a language application, we build a
ParseTreeListener implementation containing  application specific code
that typically calls into a larger surrounding application.
ANTLR generates a ParseTreeListener subclass specific to each grammar with
enter and exit methods for each rule.

Parse Tree Visitors:

There are situations, however, where we want to control the walk itself,
explicitly calling methods to visit children. Option -visitor asks ANTLR to
generate a visitor interface from a grammar with a visit method per rule.

A lexer breaks up an input stream of characters into tokens and passes them
to a parser that checks the syntax

ArrayInitParser.java:
This file contains the parser class definition specific
to grammar ArrayInit that recognizes our array language
syntax.

public class ArrayInitParser extends Parser { ... }

It contains method for each rule in the grammar as well
as some support code.

ArrayInitLexer.java:
ANTLR automatically extracts a separate parser and lexer
specification from our grammar. This file contains the lexer class definition,
which ANTLR generated by analyzing the lexical rules INT and WS as well
as the grammar literals '{', ',', and '}'. Recall that the lexer tokenizes the
input, breaking it up into vocabulary symbols. Here’s the class outline:
public class ArrayInitLexer extends Lexer { ... }

ArrayInit.tokens:
ANTLR assigns a token type number to each token we
define and stores these values in this file. It's needed
when we split a large grammar into multiple smaller
grammars so that ANTLR can synchronize all the token
type numbers.

ArrayListener.java, ArrayInitBaseListener.java:
By default, ANTLR parsers build a
tree from the input. By walking that tree, a tree walker can fire “events”
(callbacks) to a listener object that we provide. ArrayInitListener is the interface
that describes the callbacks we can implement. ArrayInitBaseListener is a set
of empty default implementations. This class makes it easy for us to
override just the callbacks we’re interested in.

javac *.java to compile and create .class file for your grammar after running antlr4 on your grammar.

grun ArrayInit init -tokens
➾ {99, 3, 451}
For example, [@5,8:10='451',<4>,1:8] indicates that it’s
the token at index 5 (indexed from 0), goes from character position 8 to 10
(inclusive starting from 0), has text 451, has token type 4 (INT), is on line 1
(from 1), and is at character position 8 (starting from zero and counting tabs
as a single character).

4.1 Matching an Arithmetic Expression Language from book
